<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="theme-color" content="#0b0b0b" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="COMPA-POL" />
  <title>COMPA-POL</title>
  <script>
    (function(){
      // Reset manual de SW/caches: abre la URL con ?reset_sw=1
      try{
        const u = new URL(window.location.href);
        if (u.searchParams.get('reset_sw') !== '1') return;
        const doneKey = 'compa_reset_sw_done_v1';
        if (sessionStorage.getItem(doneKey) === '1') return;
        sessionStorage.setItem(doneKey, '1');
        (async () => {
          try{
            if ('serviceWorker' in navigator){
              const regs = await navigator.serviceWorker.getRegistrations();
              await Promise.all(regs.map(r => r.unregister()));
            }
          }catch{}
          try{
            if (window.caches && typeof window.caches.keys === 'function'){
              const keys = await window.caches.keys();
              await Promise.all(keys.map(k => window.caches.delete(k)));
            }
          }catch{}
          u.searchParams.delete('reset_sw');
          u.searchParams.set('v', String(Date.now()));
          window.location.replace(u.toString());
        })();
      }catch{}
    })();
  </script>
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png" />
  <link rel="apple-touch-icon" href="apple-touch-icon.png" />
  <link rel="manifest" href="manifest.webmanifest" />
  <link rel="stylesheet" href="compa.css?v=21">
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore-compat.js"></script>
  <style>
    /* ===== Filiaciones: botón de alta (sin contenedor vacío visible) ===== */
    /* Oculta SIEMPRE el wrap si no hay fichas; se mostrará por JS cuando existan */
    #filiWrap{ display:none; }
    #filiacionesOut:empty{ display:none; }

    /* Overlay de imagen SIEMPRE por encima del bottomDock */
    #imgOverlay{ z-index: 200500 !important; }

    /* ===== Auth gate ===== */
    body.auth-locked #app{ display:none !important; }
    #loginGate{
      position:fixed;
      inset:0;
      z-index:300000;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      background:rgba(0,0,0,.62);
      backdrop-filter:blur(10px) saturate(120%);
      -webkit-backdrop-filter:blur(10px) saturate(120%);
    }
    #loginGate[hidden]{ display:none !important; }
    .loginCard{
      width:min(460px, 94vw);
      border:1px solid rgba(255,255,255,.34);
      border-radius:18px;
      padding:16px;
      background:linear-gradient(165deg, rgba(244,247,252,.22), rgba(216,221,231,.14));
      box-shadow:0 20px 40px rgba(0,0,0,.36), inset 0 1px 0 rgba(255,255,255,.45);
      color:#fff;
    }
    .loginTitle{ margin:0 0 8px; font-weight:800; font-size:18px; }
    .loginHint{ margin:0 0 12px; font-size:13px; opacity:.9; }
    #loginStatus{
      min-height:18px;
      margin-top:10px;
      font-size:12px;
      color:#ffd4d4;
    }
    #loginSubmit{
      margin-top:12px;
      width:100%;
      min-height:46px;
      font-weight:800;
    }
  </style>
</head>
<body class="auth-locked">
<svg class="fx-defs" width="0" height="0" aria-hidden="true" focusable="false">
  <defs>
    <filter id="glass-distort" x="-20%" y="-20%" width="140%" height="140%">
      <feTurbulence type="fractalNoise" baseFrequency="0.007 0.014" numOctaves="1" seed="7" result="noise"/>
      <feDisplacementMap in="SourceGraphic" in2="noise" scale="1.8" xChannelSelector="R" yChannelSelector="G"/>
    </filter>
  </defs>
</svg>
<div id="bg" aria-hidden="true"></div>
<div id="app">
  <header class="hero" aria-label="Cabecera institucional">
    <h1>COMPA·POL</h1>
  </header>
  <p id="status" class="muted" aria-live="polite"></p>

  <input id="f" class="fileinput" type="file" accept="image/*" multiple />

<div id="topDock">
  <div class="emoji-row">
    <label for="f" class="filebtn">◎</label>
    <button id="btnToggleFili" type="button">⊕<span id="filiCountBadge" aria-hidden="true"></span></button>
    <button id="btnToggleCompare" type="button">≣</button>
  </div>
</div>

<div class="row">
  <div class="card" id="mainCard">
      <div id="thumbs" class="grid" hidden></div>

<!-- Filiaciones (debajo de las fotos) -->
<div id="filiWrap">
  <div id="filiacionesOut" class="two"></div>
</div>
</div>
  <!-- Visor de imagen + edición (móvil) -->

<!-- Comparecencia (debajo de las fotos) -->
<div class="card" id="compareCard" style="display:none; margin-top:14px">
  <div id="compareWrap">
    <label for="docOut">Comparecencia</label>
    <textarea id="docOut"></textarea>

    <div style="margin-top:10px;text-align:right">
      <button type="button" id="btnChatGPT">ChatGPT</button>
    </div>
  </div>
</div>
    </div>
  <div class="card" id="bottomDock">
    <div class="emoji-row">
      <button id="btnDescargar" type="button">↓</button>
      <button id="btnCloud" type="button">☁️</button>
      <button id="btnLimpiar" type="button">⟳</button>
    </div>
  </div>
</div>

  <!-- Visor de imagen + edición (móvil) -->
  <div id="imgOverlay" aria-hidden="true">
    <div class="topbar">
      <button id="ovRotate" type="button" aria-label="Girar 90 grados antihorario">↺</button>
      <div class="t" id="ovTitle">Imagen</div>
      <button id="ovCloseTop" type="button" aria-label="Volver">↩︎</button>
    </div>
    <div class="imgwrap">
      <img id="ovImg" alt="Documento" />
    </div>
    <div class="formwrap">
      <div id="ovForm"></div>
    </div>
    <button id="ovClose" type="button">Cerrar</button>
  </div>

  <!-- Modal de proceso (envío/polling) -->
  <div id="jobOverlay" aria-hidden="true">
    <div class="backdrop"></div>
    <div class="panel" role="dialog" aria-modal="true" aria-labelledby="jobTitle">
      <div class="title" id="jobTitle">Procesando…</div>
      <div class="msg" id="jobMsg">Preparando envío…</div>
      <div class="timer" id="jobTimer" aria-live="polite">Tiempo: 00:00</div>
      <div class="bar" aria-hidden="true"><i></i></div>
      <div class="actions">
        <button id="jobCancel" type="button" class="secondary">Cancelar</button>
      </div>
    </div>
  </div>

  <div id="loginGate" role="dialog" aria-modal="true" aria-labelledby="loginTitle">
    <div class="loginCard">
      <h2 class="loginTitle" id="loginTitle">Acceso COMPAPOL</h2>
      <p class="loginHint">Inicia sesión</p>
      <form id="loginForm" autocomplete="on">
        <label for="loginEmail">Email</label>
        <input id="loginEmail" name="email" type="email" inputmode="email" autocomplete="username email" required>
        <label for="loginPass">Contraseña</label>
        <input id="loginPass" name="password" type="password" autocomplete="current-password" required>
        <button id="loginSubmit" type="submit">Entrar</button>
      </form>
      <div id="loginStatus" aria-live="polite"></div>
    </div>
  </div>

<script src="js/crypto-js.min.js?v=1"></script>
<script src="js/cifrado_descarga.js?v=3"></script>
<script>
/* ========= Config =========
   Modo “NO SE CORTA”:
   - Si tu backend ya es async: /process -> {job_id} (202) y /result?job_id=... -> running/done/error
   - Si tu backend aún es sync: /process devuelve directamente el JSON final (200)
*/
window.API_PROCESS_CANDIDATES = [
  `${window.location.origin}/process`,
  "https://api.0904198.xyz/process"
];
window.API_RESULT_CANDIDATES = [
  `${window.location.origin}/result`,
  "https://api.0904198.xyz/result"
];
const API_PROCESS = window.API_PROCESS_CANDIDATES[0];
const API_RESULT  = window.API_RESULT_CANDIDATES[0];
const MAX = 1200;
const JPEG_QUALITY = 0.9;

/* ========= Firebase DENUPOL (Auth + Inbox) ========= */
const DENUPOL_FIREBASE_CONFIG = {
  apiKey: "AIzaSyDUG_T31JEWDK9x_apUZVHwriWnjurNrms",
  authDomain: "denupol.firebaseapp.com",
  projectId: "denupol",
  storageBucket: "denupol.firebasestorage.app",
  messagingSenderId: "691472437659",
  appId: "1:691472437659:web:2cdd59082976841d7d513e"
};
const DENUPOL_APP_NAME = "compa-pol-denupol";
let denupolAuth = null;
let denupolDb = null;
const AUTH_LAST_EMAIL_KEY = "compa_denupol_last_email";

function initDenupolFirebase(){
  if (!window.firebase) throw new Error("Firebase SDK no cargado.");

  const existing = firebase.apps.find(a => a && a.name === DENUPOL_APP_NAME);
  const app = existing || firebase.initializeApp(DENUPOL_FIREBASE_CONFIG, DENUPOL_APP_NAME);
  denupolAuth = firebase.auth(app);
  denupolDb = firebase.firestore(app);
}

async function ensureDenupolAuth(){
  if (!denupolAuth || !denupolDb) initDenupolFirebase();
  if (!denupolAuth.currentUser) throw new Error("Sesión COMPAPOL no iniciada.");
  return denupolAuth.currentUser;
}

function getInboxPayload(){
  const raw = state.lastJson ?? {};
  const out = JSON.parse(JSON.stringify(raw));

  // Comparecencia: opcional. Si viene vacía, no se envía.
  const textKeys = ["doc", "comparecencia", "doc_texto", "texto"];
  for (const k of textKeys){
    if (!Object.prototype.hasOwnProperty.call(out, k)) continue;
    const v = out[k];
    if (typeof v !== "string" || !v.trim()) delete out[k];
  }

  // Filiaciones: opcional. Si no hay elementos, no se envía.
  if (!Array.isArray(out.filiaciones) || out.filiaciones.length === 0){
    delete out.filiaciones;
  }

  return out;
}

function hasInboxPayload(){
  const p = getInboxPayload();
  return Object.keys(p).length > 0;
}

function pickIndicativo(payload){
  const p = payload && typeof payload === "object" ? payload : {};
  const firstFili = Array.isArray(p.filiaciones) ? (p.filiaciones[0] || {}) : {};
  const candidatos = [
    p.indicativo,
    p.Indicativo,
    p.nombre_indicativo,
    p.nombreIndicativo,
    Array.isArray(p.indicativos) ? p.indicativos[0] : null,
    p?.hechos?.indicativo,
    Array.isArray(p?.hechos?.indicativos) ? p.hechos.indicativos[0] : null,
    firstFili["Indicativo"],
    firstFili["indicativo"],
    firstFili["Nombre indicativo"],
    firstFili["nombre_indicativo"]
  ];

  for (const v of candidatos){
    if (typeof v === "string" && v.trim()) return v.trim();
  }
  return "SIN INDICATIVO";
}

function buildInboxLabel(payload){
  const now = new Date();
  const meses = ["JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC"];
  const dd = String(now.getDate()).padStart(2, "0");
  const mmm = meses[now.getMonth()] || "JAN";
  const yy = String(now.getFullYear()).slice(-2);
  const hh = String(now.getHours()).padStart(2, "0");
  const indicativo = pickIndicativo(payload).toUpperCase();
  return `${indicativo} ${dd}${mmm}${yy} ${hh}H`;
}

/* ========= Estado ========= */
const state = {
  images: [],       // {name, base64, w, h}
  lastJson: null,   // JSON de trabajo (con overrides aplicados)
  aiJson: null,     // JSON base devuelto por IA (sin overrides)
  thumbOverrides: {}, // { [idx:number]: { domicilio?: string, telefono?: string } }
  polling: false,
  abort: null
};

function updateMainContentVisibility(){
  const hasFili = getFiliCount() > 0;
  const has =
    (state.images && state.images.length > 0) || hasFili;

  const hasImages = !!(state.images && state.images.length > 0);
  document.body.classList.toggle('no-images', !hasImages);
  document.body.classList.toggle('has-content', has);
}

const el = {
  f: document.getElementById('f'),
  thumbs: document.getElementById('thumbs'),
  docText: document.getElementById('docText'),
  btnEnviar: document.getElementById('btnEnviar'),
  btnCancelar: document.getElementById('btnCancelar'),
  btnLimpiar: document.getElementById('btnLimpiar'),
  btnDescargar: document.getElementById('btnDescargar'),
  btnCloud: document.getElementById('btnCloud'),
  btnCompartir: document.getElementById('btnCompartir'),
  btnToggleCompare: document.getElementById('btnToggleCompare'),
  status: document.getElementById('status'),
  docOut: document.getElementById('docOut'),
  filiWrap: document.getElementById('filiWrap'),
  filiacionesOut: document.getElementById('filiacionesOut'),
  filiCountBadge: document.getElementById('filiCountBadge'),
  btnToggleFili: document.getElementById('btnToggleFili'),
  loginGate: document.getElementById('loginGate'),
  loginForm: document.getElementById('loginForm'),
  loginEmail: document.getElementById('loginEmail'),
  loginPass: document.getElementById('loginPass'),
  loginSubmit: document.getElementById('loginSubmit'),
  loginStatus: document.getElementById('loginStatus'),
};
el.jobOverlay = document.getElementById('jobOverlay');
el.jobTitle   = document.getElementById('jobTitle');
el.jobMsg     = document.getElementById('jobMsg');
el.jobTimer   = document.getElementById('jobTimer');
el.jobCancel  = document.getElementById('jobCancel');

/* ========= Helpers ========= */
function updateFiliCountBadge(){
  const b = el.filiCountBadge;
  if (!b) return;
  const n = getFiliCount();
  b.textContent = n ? String(n) : "";
  b.style.display = n ? "inline-flex" : "none";
}

function getFiliCount(){
  const arr = Array.isArray(state?.lastJson?.filiaciones) ? state.lastJson.filiaciones : [];
  return arr.reduce((acc, it) => acc + ((it && typeof it === "object") ? 1 : 0), 0);
}

function compactFiliacionesState(){
  const arr = Array.isArray(state?.lastJson?.filiaciones) ? state.lastJson.filiaciones : null;
  if (!arr) return;

  const dense = [];
  const mapOldToNew = new Map();
  for (let i = 0; i < arr.length; i++){
    const it = arr[i];
    if (!it || typeof it !== "object") continue;
    mapOldToNew.set(i, dense.length);
    dense.push(it);
  }
  if (dense.length === arr.length) return;

  state.lastJson.filiaciones = dense;

  if (Array.isArray(state?.aiJson?.filiaciones)){
    const aiDense = [];
    for (let i = 0; i < state.aiJson.filiaciones.length; i++){
      if (!mapOldToNew.has(i)) continue;
      aiDense.push(state.aiJson.filiaciones[i]);
    }
    state.aiJson.filiaciones = aiDense;
  }

  if (Array.isArray(state.images)){
    state.images = state.images.filter(im => mapOldToNew.has(Number(im?.fi)));
    for (const im of state.images){
      const oldFi = Number(im?.fi);
      const newFi = mapOldToNew.get(oldFi);
      if (typeof newFi === "number"){
        im.fi = newFi;
        im.name = `Filiación ${newFi + 1}`;
      }
    }
  }

  if (state.thumbOverrides && typeof state.thumbOverrides === "object"){
    const next = {};
    for (const [oldK, v] of Object.entries(state.thumbOverrides)){
      const oldI = Number(oldK);
      const newI = mapOldToNew.get(oldI);
      if (typeof newI === "number") next[String(newI)] = v;
    }
    state.thumbOverrides = next;
  }
}

function updateFiliUI(){
  const n = getFiliCount();

  // Badge
  updateFiliCountBadge();
  document.body.classList.toggle('fili-has', n > 0);

  // Si NO hay filiaciones, el contenedor NO debe verse nunca
  if (el.filiWrap) el.filiWrap.style.display = n ? '' : 'none';
  if (el.filiacionesOut) el.filiacionesOut.style.display = n ? '' : 'none';
  updateMainContentVisibility();
}
let _filiDelegated = false;
function ensureFiliDelegation(){
  if (_filiDelegated) return;
  if (!el.filiacionesOut) return;
  _filiDelegated = true;

  const handler = (ev) => {
    const t = ev.target;
    if (!t || !t.getAttribute) return;
    const fi = t.getAttribute('data-fi');
    const k  = t.getAttribute('data-k');
    if (fi == null || k == null) return;

    const i = Number(fi);
    if (!Number.isFinite(i)) return;

    if (!state.lastJson || typeof state.lastJson !== 'object') state.lastJson = {};
    if (!Array.isArray(state.lastJson.filiaciones)) state.lastJson.filiaciones = [];
    if (!state.lastJson.filiaciones[i] || typeof state.lastJson.filiaciones[i] !== 'object') {
      state.lastJson.filiaciones[i] = {};
    }

    state.lastJson.filiaciones[i][k] = t.value;

    // Persistencia de Condición (front-end) aunque vuelva del backend
    if (k === "Condición"){
      try{ _ensureOverride(i).condicion = t.value; }catch(e){}
    }
  };

  // Captura tanto input (teclado) como change (selects)
  el.filiacionesOut.addEventListener('input', handler);
  el.filiacionesOut.addEventListener('change', handler);
}
function setStatus(msg, kind="muted"){
  // Puede no existir #status (según layout). No debe romper toda la app.
  if (!el.status) return;
  el.status.className = kind === "ok" ? "ok" : kind === "err" ? "err" : "muted";
  el.status.textContent = msg || "";
}

function escapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
    .replaceAll('"',"&quot;").replaceAll("'","&#039;");
}

function renderThumbs(){
  el.thumbs.innerHTML = state.images.map((it, idx) => `
    <div class="thumb">
      <img src="${it.base64}" alt="${escapeHtml(it.name)}" data-thumb="${idx}">
      <div class="small" title="${escapeHtml(it.name)}"><b>${escapeHtml(it.name)}</b></div>
      <div class="muted small">${it.w}×${it.h}</div>
      <div class="thumb-actions">
        <button type="button" data-save="${idx}" aria-label="Guardar en el dispositivo">↧</button>
        <button type="button" data-del="${idx}" aria-label="Quitar">✕</button>
      </div>
    </div>
  `).join("");

  [...el.thumbs.querySelectorAll('button[data-del]')].forEach(b=>{
    b.onclick = () => {
  const imgIdx = Number(b.getAttribute('data-del'));
  const img = state.images?.[imgIdx];
  if (!img) return;

  const removedFi = Number.isFinite(Number(img.fi)) ? Number(img.fi) : imgIdx;

  // 1) borra imagen (por índice de miniatura)
  state.images.splice(imgIdx, 1);

  // 2) borra la filiación asociada (por fi)
  if (Array.isArray(state.lastJson?.filiaciones) && state.lastJson.filiaciones.length > removedFi){
    state.lastJson.filiaciones.splice(removedFi, 1);
  }
  if (Array.isArray(state.aiJson?.filiaciones) && state.aiJson.filiaciones.length > removedFi){
    state.aiJson.filiaciones.splice(removedFi, 1);
  }

  // 3) reindexa fi de las imágenes restantes (porque ha cambiado el índice de filiación)
  for (const im of (state.images || [])){
    const f = Number(im?.fi);
if (Number.isFinite(f) && f > removedFi) { im.fi = f - 1; im.name = `Filiación ${im.fi+1}`; }
  }

  // 4) reindexa overrides por índice de filiación
  try{ shiftThumbOverridesAfterRemoval(removedFi); }catch{}

  renderThumbs();
  if (state.lastJson) renderFiliaciones(state.lastJson);
};
  });

  [...el.thumbs.querySelectorAll('button[data-save]')].forEach(b=>{
    b.onclick = async () => {
      const i = Number(b.getAttribute('data-save'));
      try{
        await shareOrDownloadImage(i);
      }catch(e){
        console.error(e);
        setStatus('No se pudo guardar/compartir.', 'err');
      }
    };
  });

  // Click en miniatura -> overlay rápido (domicilio/teléfono)
  [...el.thumbs.querySelectorAll('img[data-thumb]')].forEach(img => {
    img.style.cursor = 'pointer';
    img.onclick = () => {
      const i = Number(img.getAttribute('data-thumb'));
      openThumbOverlay(i);
    };
  });
}

function _ensureOverride(i){
  const k = String(i);
  if (!state.thumbOverrides || typeof state.thumbOverrides !== 'object') state.thumbOverrides = {};
  if (!state.thumbOverrides[k] || typeof state.thumbOverrides[k] !== 'object') {
    state.thumbOverrides[k] = { domicilio:"", telefono:"", condicion:"" };
  } else {
    // compat con versiones anteriores
    if (typeof state.thumbOverrides[k].domicilio !== 'string') state.thumbOverrides[k].domicilio = "";
    if (typeof state.thumbOverrides[k].telefono  !== 'string') state.thumbOverrides[k].telefono  = "";
    if (typeof state.thumbOverrides[k].condicion !== 'string') state.thumbOverrides[k].condicion = "";
  }
  return state.thumbOverrides[k];
}

function shiftThumbOverridesAfterRemoval(removedIdx){
  // thumbOverrides guarda claves como strings "0","1",...
  const src = (state.thumbOverrides && typeof state.thumbOverrides === 'object') ? state.thumbOverrides : {};
  const dst = {};
  const keys = Object.keys(src);
  for (const k of keys){
    const n = Number(k);
    if (!Number.isFinite(n)) continue;
    if (n < removedIdx) dst[String(n)] = src[k];
    else if (n > removedIdx) dst[String(n - 1)] = src[k];
    // si n === removedIdx, se descarta
  }
  state.thumbOverrides = dst;
}

function applyThumbOverrides(){
  // Aplica overrides sobre state.lastJson usando state.aiJson como base.
  if (!state.lastJson || !Array.isArray(state.lastJson.filiaciones)) return;
  if (!state.aiJson || !Array.isArray(state.aiJson.filiaciones)) return;

  const n = Math.min(state.lastJson.filiaciones.length, state.aiJson.filiaciones.length);
  for (let i = 0; i < n; i++){
    const base = state.aiJson.filiaciones[i] || {};
    const cur  = state.lastJson.filiaciones[i] || {};
    const ov = state.thumbOverrides?.[String(i)];

    // DOMICILIO: si hay override -> pisa; si no, vuelve al de IA
    if (ov && String(ov.domicilio || '').trim()){
      cur["Domicilio"] = String(ov.domicilio).trim();
    } else {
      cur["Domicilio"] = typeof base["Domicilio"] === 'string' ? base["Domicilio"] : (cur["Domicilio"] || "");
    }

    // TELÉFONO: si hay override -> añade campo; si no, elimina si existe
    if (ov && String(ov.telefono || '').trim()){
      cur["Teléfono"] = String(ov.telefono).trim();
    } else {
      if ("Teléfono" in cur) delete cur["Teléfono"]; // requisito: no se rellena si vacío
    }

    // CONDICIÓN: dato FRONT-END. Si hay override, siempre pisa lo que venga del backend.
    if (ov && String(ov.condicion || '').trim()){
      cur["Condición"] = String(ov.condicion).trim();
    }

    state.lastJson.filiaciones[i] = cur;
  }
}


function renderFiliaciones(obj){
  compactFiliacionesState();
  const arr = obj?.filiaciones || obj?.filiaciones_incorporadas || obj?.filiacion || [];
  if (!Array.isArray(arr) || arr.length === 0){
    // Sin fichas: no debe verse ningún contenedor vacío
    if (el.filiacionesOut) el.filiacionesOut.innerHTML = ``;
    updateFiliUI();
    return;
  }

  if (el.filiWrap) el.filiWrap.style.display = '';
  if (el.filiacionesOut) el.filiacionesOut.style.display = '';
  // Normaliza y asegura que los cambios queden en memoria (hasta Limpiar)
  if (state.lastJson && Array.isArray(state.lastJson.filiaciones)) {
    // ok
  } else {
    state.lastJson = state.lastJson || {};
    state.lastJson.filiaciones = JSON.parse(JSON.stringify(arr));
  }

  const safeImg = (fi) => {
    const nfi = Number(fi);
    const it = Array.isArray(state.images)
      ? state.images.find(im => Number(im?.fi) === nfi)
      : null;
    return (it?.base64 || "");
  };

  const pickName = (p) => {
    const n = String(p?.["Nombre"] || "").trim();
    const a = String(p?.["Apellidos"] || "").trim();
    const full = `${n} ${a}`.trim();
    return full || "Sin nombre";
  };

  const cardHtml = (p, i) => {
    const img = safeImg(i);
    const hasImg = !!img;
    const title = `Filiación ${i+1}`;
    const condicion = String(p?.["Condición"] || "").trim();
    const summary = `${pickName(p)}${condicion ? ` · ${condicion}` : ""}`;
    return `
      <article class="fili-chip ${hasImg ? "hasImage" : ""}" data-fi="${i}">
        <div class="fili-chip-row">
          <button type="button" class="fili-chip-body" data-edit="${i}" aria-label="Editar ${escapeHtml(title)}">
            ${hasImg ? `<div class="fili-chip-thumb"><img src="${img}" alt="${escapeHtml(title)}"></div>` : ""}
            <div class="fili-chip-main">
              <div class="fili-chip-title">${escapeHtml(title)}</div>
              <div class="fili-chip-sub">${escapeHtml(summary)}</div>
            </div>
          </button>
          <div class="fili-chip-actions right">
            ${hasImg ? `<button type="button" class="btnmini" data-del-img="${i}" title="Eliminar foto y filiación">✕</button>` : ``}
            ${(p && p.__manual) ? `<button type="button" class="btnmini" data-del-fi="${i}" title="Eliminar filiación">✕</button>` : ``}
          </div>
        </div>
      </article>
    `;
  };

  el.filiacionesOut.innerHTML = arr.map((p,i)=>cardHtml(p,i)).join("");
  updateFiliUI();

  // Click en cuerpo del chip -> editor fullscreen de filiación
  el.filiacionesOut.querySelectorAll('button[data-edit]').forEach(b => {
    b.addEventListener('click', () => {
      const i = Number(b.getAttribute('data-edit'));
      openFiliacionOverlay(i);
    });
  });

  // Eliminar foto + filiación desde chip
  el.filiacionesOut.querySelectorAll('button[data-del-img]').forEach(b => {
    b.addEventListener('click', () => {
      const i = Number(b.getAttribute('data-del-img'));
      const ok = confirm(`¿Eliminar la filiación ${i+1}?`);
      if (!ok) return;

      const imgIdx = Array.isArray(state.images) ? state.images.findIndex(im => Number(im?.fi) === i) : -1;
      const removedFi = i;
      if (imgIdx >= 0) state.images.splice(imgIdx, 1);

      if (Array.isArray(state.lastJson?.filiaciones) && state.lastJson.filiaciones.length > removedFi){
        state.lastJson.filiaciones.splice(removedFi, 1);
      }
      if (Array.isArray(state.aiJson?.filiaciones) && state.aiJson.filiaciones.length > removedFi){
        state.aiJson.filiaciones.splice(removedFi, 1);
      }
      for (const im of (state.images || [])){
        const f = Number(im?.fi);
        if (Number.isFinite(f) && f > removedFi) { im.fi = f - 1; im.name = `Filiación ${im.fi+1}`; }
      }
      try{ shiftThumbOverridesAfterRemoval(removedFi); }catch(_){}
      renderThumbs();
      renderFiliaciones(state.lastJson);
      setExportEnabled(!!state.lastJson);
    });
  });

  // Botón eliminar (solo para filiaciones sin imagen)
  el.filiacionesOut.querySelectorAll('button[data-del-fi]').forEach(b => {
    b.addEventListener('click', () => {
      const i = Number(b.getAttribute('data-del-fi'));
      const ok = confirm(`¿Eliminar la filiación ${i+1}?`);
      if (!ok) return;

      // 1) Borra la filiación (índice real del array filiaciones)
      if (!state.lastJson) state.lastJson = {};
      if (!Array.isArray(state.lastJson.filiaciones)) state.lastJson.filiaciones = [];
      state.lastJson.filiaciones.splice(i, 1);

      // 2) Si existe imagen vinculada por fi==i, la borramos. (NO por índice del array images)
      if (Array.isArray(state.images) && state.images.length){
        const imgIdx = state.images.findIndex(im => Number(im?.fi) === i);
        if (imgIdx >= 0){
          state.images.splice(imgIdx, 1);
        }
        // Reindexa fi de las imágenes restantes: todo lo que estaba por encima baja 1
        for (const im of state.images){
          const f = Number(im?.fi);
if (Number.isFinite(f) && f > i) { im.fi = f - 1; im.name = `Filiación ${im.fi+1}`; }
        }
        renderThumbs();
      }

      // 3) Mantener aiJson alineado (mismo índice de filiaciones)
      if (state.aiJson && Array.isArray(state.aiJson.filiaciones)) state.aiJson.filiaciones.splice(i, 1);

      // 4) Reindexa overrides (si borras una filiación intermedia, las claves posteriores bajan 1)
      try{ shiftThumbOverridesAfterRemoval(i); }catch(e){
        if (state.thumbOverrides && typeof state.thumbOverrides === 'object') delete state.thumbOverrides[String(i)];
      }

      renderFiliaciones(state.lastJson);
      setExportEnabled(!!state.lastJson);
    });
  });
}

function setBusy(on){
  if (el.btnEnviar) el.btnEnviar.disabled = !!on;
  if (el.btnCancelar) el.btnCancelar.disabled = !on;
}

function setExportEnabled(on){
  if (el.btnDescargar) el.btnDescargar.disabled = false;
  if (el.btnCloud) el.btnCloud.disabled = false;
  if (el.btnCompartir) el.btnCompartir.disabled = false;
}

function resolveImageIndexByFi(fi){
  if (!Array.isArray(state.images) || state.images.length === 0) return -1;
  const n = Number(fi);
  let idx = state.images.findIndex(im => Number(im?.fi) === n && !!im?.base64);
  if (idx >= 0) return idx;
  if (Number.isInteger(n) && n >= 0 && n < state.images.length && !!state.images[n]?.base64) return n;
  idx = state.images.findIndex(im => !!im?.base64);
  return idx;
}

function showLoginGate(msg){
  if (el.loginGate) el.loginGate.hidden = false;
  if (el.loginStatus) el.loginStatus.textContent = msg || "";
  const remembered = localStorage.getItem(AUTH_LAST_EMAIL_KEY) || "";
  if (el.loginEmail && !el.loginEmail.value && remembered) el.loginEmail.value = remembered;
  try{ el.loginEmail?.focus(); }catch{}
}

function hideLoginGate(){
  if (el.loginGate) el.loginGate.hidden = true;
  if (el.loginStatus) el.loginStatus.textContent = "";
}

function lockApp(){
  document.body.classList.add("auth-locked");
  setExportEnabled(!!state.lastJson);
}

function unlockApp(){
  document.body.classList.remove("auth-locked");
  setExportEnabled(!!state.lastJson);
}

async function bootstrapAuthGate(){
  initDenupolFirebase();
  try{
    await denupolAuth.setPersistence(firebase.auth.Auth.Persistence.LOCAL);
  }catch{}

  if (el.loginForm){
    el.loginForm.addEventListener("submit", async (ev) => {
      ev.preventDefault();
      if (el.loginStatus) el.loginStatus.textContent = "";
      const email = (el.loginEmail?.value || "").trim();
      const pass = el.loginPass?.value || "";
      if (!email || !pass) return;

      if (el.loginSubmit) el.loginSubmit.disabled = true;
      try{
        await denupolAuth.signInWithEmailAndPassword(email, pass);
        localStorage.setItem(AUTH_LAST_EMAIL_KEY, email);
      }catch(err){
        const m = String(err?.message || err || "Error de login");
        if (el.loginStatus) el.loginStatus.textContent = `ERROR: ${m}`;
      }finally{
        if (el.loginSubmit) el.loginSubmit.disabled = false;
      }
    });
  }

  denupolAuth.onAuthStateChanged((user) => {
    if (user){
      unlockApp();
      hideLoginGate();
      if (el.loginPass) el.loginPass.value = "";
      return;
    }
    lockApp();
    showLoginGate("Introduce tus credenciales COMPAPOL.");
  });
}

function getJsonString(){
  return JSON.stringify(state.lastJson ?? {}, null, 2);
}

function downloadText(filename, text){
  const blob = new Blob([text], {type: 'application/json;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 1000);
}

function dataUrlToBlob(dataUrl){
  const s = String(dataUrl || "");
  const comma = s.indexOf(',');
  if (comma < 0) return new Blob([], {type:'application/octet-stream'});
  const header = s.slice(0, comma);
  const b64 = s.slice(comma + 1);
  const m = /data:([^;]+);base64/i.exec(header);
  const mime = (m && m[1]) ? m[1] : 'application/octet-stream';
  const bin = atob(b64);
  const u8 = new Uint8Array(bin.length);
  for (let i=0;i<bin.length;i++) u8[i] = bin.charCodeAt(i);
  return new Blob([u8], {type:mime});
}

async function shareOrDownloadImage(idx){
  const it = state.images?.[idx];
  if (!it || !it.base64) return;

  const ua = navigator.userAgent || "";
  const isIOS = /iPad|iPhone|iPod/.test(ua) || (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
  const blob = dataUrlToBlob(it.base64);
  const ext = (blob.type === 'image/png') ? 'png' : 'jpg';
  const name = (it.name && String(it.name).trim()) ? String(it.name).trim() : `imagen_${idx+1}.${ext}`;
  const file = new File([blob], name, {type: blob.type || 'image/jpeg'});

  const showIOSSaveOverlay = () => {
    let ov = document.getElementById('iosPhotoSaveOverlay');
    if (!ov){
      ov = document.createElement('div');
      ov.id = 'iosPhotoSaveOverlay';
      ov.style.position = 'fixed';
      ov.style.inset = '0';
      ov.style.zIndex = '450000';
      ov.style.background = 'rgba(8,12,22,.92)';
      ov.style.display = 'flex';
      ov.style.flexDirection = 'column';
      ov.style.padding = '12px';
      ov.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:center;color:#dff0ff;font-weight:700;margin-bottom:8px">
          <span>Guardar en Fotos</span>
          <button type="button" id="iosPhotoSaveClose" style="min-width:42px;height:42px;border-radius:999px;border:1px solid rgba(255,255,255,.35);background:rgba(255,255,255,.12);color:#fff">↩︎</button>
        </div>
        <div style="color:#c8daef;font-size:13px;margin:0 0 8px">Mantén pulsado sobre la imagen y elige "Guardar en Fotos".</div>
        <img id="iosPhotoSaveImg" alt="Foto" style="width:100%;height:100%;object-fit:contain;border-radius:10px;background:#0f1728" />
      `;
      document.body.appendChild(ov);
      ov.querySelector('#iosPhotoSaveClose')?.addEventListener('click', ()=>ov.remove());
    }
    const img = ov.querySelector('#iosPhotoSaveImg');
    if (img) img.src = it.base64;
  };

  if (isIOS){
    try{
      if (navigator.share && (!navigator.canShare || navigator.canShare({ files:[file] }))) {
        await navigator.share({ files:[file], title:'Imagen', text:'' });
        setStatus('Usa "Guardar imagen" para enviarla a Fotos.', 'ok');
        return;
      }
    }catch(e){
      const msg = String(e?.message || '').toLowerCase();
      if (msg.includes('abort') || msg.includes('cancel')) return;
    }
    showIOSSaveOverlay();
    setStatus('Mantén pulsado y elige "Guardar en Fotos".', 'muted');
    return;
  }

  try{
    if (navigator.share && (!navigator.canShare || navigator.canShare({ files:[file] }))) {
      await navigator.share({ files:[file], title:'Imagen', text:'' });
      setStatus('Imagen compartida.', 'ok');
      return;
    }
  }catch(e){
    // si el usuario cancela share, no lo tratamos como error
    const msg = String(e?.message || '').toLowerCase();
    if (msg.includes('abort') || msg.includes('cancel')) return;
  }

  // Otros entornos: descarga normal.
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = name;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 1500);
  setStatus('Descargando imagen…', 'muted');
}

if (el.btnEnviar) el.btnEnviar.onclick = async () => {
  setStatus("Enviando…");
  showJobOverlay('Enviando…', 'Subiendo datos al servidor…');
  setBusy(true);
  state.polling = true;
  const t0 = performance.now();
  let finishedOk = false;
  let totalSecs = 0;

  const payload = {
    images_base64: state.images.map(x => x.base64),
    texto: el.docText?.value || ""
  };
  
  try{
    const start = await startJob(payload);

    if (start.mode === 'sync'){
      updateJobOverlay('Recibiendo respuesta…', 'Procesando…');
    } else {
      updateJobOverlay('Procesando… (esperando resultado)', 'Procesando…');
    }

    let out;
    if (start.mode === "sync"){
      out = start.out;
    } else {
      setStatus("Procesando…");
      updateJobOverlay('Procesando… (consultando resultado)', 'Procesando…');
      out = await pollResult(start.job_id);
    }

    // ---- Normaliza salida (algunos backends envuelven el resultado en {out:{...}} o {data:{...}})
    const OUT = (out && typeof out === 'object' && (out.out && typeof out.out === 'object')) ? out.out :
                (out && typeof out === 'object' && (out.data && typeof out.data === 'object')) ? out.data :
                out;
    if (OUT && typeof OUT === "object"){
      if (!Array.isArray(OUT.filiaciones) && Array.isArray(OUT.filiaciones_incorporadas)){
        OUT.filiaciones = OUT.filiaciones_incorporadas;
      }
      if (!Array.isArray(OUT.filiaciones) && Array.isArray(OUT.filiacion)){
        OUT.filiaciones = OUT.filiacion;
      }
    }
    // Mapear salida de IA por filiación real (fi) en vez de por índice de respuesta.
    // El backend devuelve filiaciones en el orden de images_base64; cada imagen conoce su fi.
    const mappedOut = JSON.parse(JSON.stringify(OUT || {}));
    if (Array.isArray(mappedOut.filiaciones) && Array.isArray(state.images) && state.images.length){
      const remap = [];
      for (let i = 0; i < mappedOut.filiaciones.length; i++){
        const fi = Number(state.images[i]?.fi);
        const targetFi = (Number.isFinite(fi) && fi >= 0) ? fi : i;
        remap[targetFi] = mappedOut.filiaciones[i];
      }
      mappedOut.filiaciones = remap;
    }

    // Guardamos el JSON base de IA y creamos un JSON de trabajo (editable + overrides)
    state.aiJson = JSON.parse(JSON.stringify(mappedOut || {}));
    const prev = JSON.parse(JSON.stringify(state.lastJson || {}));
    state.lastJson = JSON.parse(JSON.stringify(mappedOut || {}));
    if (Array.isArray(prev?.filiaciones)){
      if (!Array.isArray(state.lastJson.filiaciones)) state.lastJson.filiaciones = [];
      for (let i = 0; i < prev.filiaciones.length; i++){
        const oldFi = prev.filiaciones[i];
        if (!oldFi || typeof oldFi !== "object") continue;

        // Si backend no devolvió esta filiación, conserva la que ya teníamos.
        if (!state.lastJson.filiaciones[i] || typeof state.lastJson.filiaciones[i] !== "object"){
          state.lastJson.filiaciones[i] = JSON.parse(JSON.stringify(oldFi));
          continue;
        }

        // Si sí existe, completa huecos sin pisar lo nuevo del backend.
        for (const k in oldFi){
          const v = oldFi[k];
          if (typeof v !== "string" || !v.trim()) continue;
          const cur = state.lastJson.filiaciones[i][k];
          if (!cur || !String(cur).trim()){
            state.lastJson.filiaciones[i][k] = v;
          }
        }
      }
    }
    // Aplica overrides de miniaturas (domicilio/teléfono)
    try{ applyThumbOverrides(); }catch(e){}

    setExportEnabled(!!state.lastJson);

    const docCandidate =
      (typeof OUT?.doc === 'string' && OUT.doc) ||
      (typeof OUT?.comparecencia === 'string' && OUT.comparecencia) ||
      (typeof OUT?.doc_texto === 'string' && OUT.doc_texto) ||
      (typeof OUT?.respuesta_modelo === 'string' && OUT.respuesta_modelo) ||
      (typeof OUT?.texto === 'string' && OUT.texto) ||
      "";

    el.docOut.value = docCandidate;

    // Debug visible (sin consola): si viene vacío, muestro claves para saber qué está llegando
    if (!docCandidate) {
      const keys = (OUT && typeof OUT === 'object') ? Object.keys(OUT).slice(0, 25).join(', ') : String(typeof OUT);
      setStatus(`OK pero DOC vacío · claves: ${keys}`, 'err');
    }

    renderFiliaciones(state.lastJson);

    totalSecs = (performance.now() - t0) / 1000;
    setStatus(`OK · ${totalSecs.toFixed(1)}s`, "ok");
    finishedOk = true;
  }catch(err){
    console.error(err);
    if (String(err?.message || "").toLowerCase().includes("cancelled")){
      setStatus("Cancelado.", "muted");
    } else {
      setStatus(`Error: ${err.message}`, "err");
    }
  }finally{
    state.polling = false;
    state.abort = null;
    setBusy(false);
    if (finishedOk){
      if (typeof markJobOverlayDone === "function"){
        markJobOverlayDone(totalSecs);
      } else {
        hideJobOverlay();
      }
    } else {
      hideJobOverlay();
    }
  }
};

if (el.btnCancelar) el.btnCancelar.onclick = () => {
  state.polling = false;
  try{ state.abort?.abort(); }catch{}
  // Nota: no paramos la cámara al cancelar el job
  hideJobOverlay();
}

/* ========= Botones superiores ========= */
(function(){
  const bC = el.btnToggleCompare;
  const bF = el.btnToggleFili;
  const compareCard = document.getElementById('compareCard');
  const topDock = document.getElementById('topDock');

  function scrollToEl(target){
    if (!target) return;
    const dockH = topDock ? topDock.getBoundingClientRect().height : 0;
    const y = Math.max(0, window.scrollY + target.getBoundingClientRect().top - dockH - 12);
    window.scrollTo({ top: y, behavior: 'smooth' });
  }

  function scrollToCompare(){
    // Espera al repaint para asegurar que compareCard ya es visible.
    requestAnimationFrame(() => {
      requestAnimationFrame(() => scrollToEl(compareCard));
    });
  }

  function scrollToFirstFili(){
    const firstFili = document.querySelector('.fili-chip');
    if (firstFili) {
      scrollToEl(firstFili);
      return;
    }
    const mainCard = document.getElementById('mainCard');
    if (mainCard) scrollToEl(mainCard);
  }

  const syncCompare = () => {
    const cOn = document.body.classList.contains('compare-on');
    if (bC){
      bC.textContent = '≣';
    }
    if (bF){
      if (bF.firstChild && bF.firstChild.nodeType === Node.TEXT_NODE) {
        bF.firstChild.nodeValue = '⊕';
      } else {
        bF.insertAdjacentText('afterbegin', '⊕');
      }
    }
    updateMainContentVisibility();
    updateFiliUI();
  };

  document.body.classList.remove('compare-on');
  syncCompare();

  bC?.addEventListener('click', () => {
    const willOn = !document.body.classList.contains('compare-on');
    document.body.classList.toggle('compare-on', willOn);
    syncCompare();
    if (willOn) scrollToCompare();
    else scrollToFirstFili();
  });
})();

/* ========= Añadir filiación a mano ========= */
(function(){
  const b = el.btnToggleFili;
  if (!b) return;

  const schema_keys = [
    "Condición",
    "Nombre","Apellidos","Tipo de documento","Nº Documento","Sexo",
    "Nacionalidad","Fecha de nacimiento","Lugar de nacimiento",
    "Nombre de los Padres","Domicilio","Teléfono",
    "idSituacionEsp","idComprobada","cacheo"
  ];

  function ensureLastJson(){
    if (!state.lastJson || typeof state.lastJson !== 'object') state.lastJson = {};
    if (!Array.isArray(state.lastJson.filiaciones)) state.lastJson.filiaciones = [];
  }

  function blankFili(){
    const it = {};
    for (const k of schema_keys) it[k] = "";
    it["idSituacionEsp"] = "Legal";
    it["idComprobada"] = "Si";
    it["cacheo"] = "Ninguno";
    // Marca interna: es una filiación creada a mano (NO debe intentar vincularse a imagen por índice)
    // No debe salir en el JSON exportado.
    try{
      Object.defineProperty(it, '__manual', { value:true, enumerable:false });
    }catch(e){
      // fallback (si defineProperty fallase en algún entorno raro)
      it.__manual = true;
    }
    return it;
  }

  b.addEventListener('click', () => {
    ensureLastJson();
    state.lastJson.filiaciones.push(blankFili());
    updateFiliUI();

    renderFiliaciones(state.lastJson);
    setExportEnabled(true);

    try{
      const cards = document.querySelectorAll('.fili-chip');
      cards[cards.length - 1]?.scrollIntoView?.({behavior:'smooth', block:'start'});
    }catch{}
  });
})();

/* ========= Persistir edición de ComparecencIA en el JSON =========
   - Si el backend no devuelve doc/comparecencia, al editar docOut se crea en state.lastJson.
   - Si ya existe la clave "comparecencia" en el JSON, se mantiene esa clave; si no, se usa "doc".
*/
if (el.docOut){
  el.docOut.addEventListener('input', () => {
    if (!state.lastJson || typeof state.lastJson !== 'object') state.lastJson = {};

    const v = el.docOut.value || "";

    // Si el JSON ya venía con "comparecencia", seguimos actualizando esa.
    if (Object.prototype.hasOwnProperty.call(state.lastJson, 'comparecencia')){
      state.lastJson.comparecencia = v;
    } else {
      state.lastJson.doc = v;
    }

    // Si hay otra clave de texto usada por tu backend, actualízala también sin romper nada.
    if (Object.prototype.hasOwnProperty.call(state.lastJson, 'doc_texto')){
      state.lastJson.doc_texto = v;
    }
    if (Object.prototype.hasOwnProperty.call(state.lastJson, 'texto')){
      state.lastJson.texto = v;
    }

    setExportEnabled(true);
  });
}

// Botón ChatGPT (alternativa comparecencia)
const btnChatGPT = document.getElementById('btnChatGPT');
if (btnChatGPT){
  btnChatGPT.onclick = () => {
    window.open(
      "https://chatgpt.com/g/g-68fe060630348191b62c44416164a37d-comparecencia",
      "_blank",
      "noopener"
    );
  };
}

/* ========= Export encriptado (wrapper CompaCifrado) ========= */
if (el.btnDescargar) el.btnDescargar.onclick = async () => {
  if (!state.lastJson) return;
  if (!window.CompaCifrado?.wrapEncryptedJSON) {
    setStatus('Falta cifrado_descarga.js', 'err');
    return;
  }
  const rnd = Math.floor(1000 + Math.random() * 9000);
const wrappedText = await window.CompaCifrado.wrapEncryptedJSON(state.lastJson);

  downloadText(`Proyecto-${rnd}.enc.json`, wrappedText);
  setStatus('JSON ENCRIPTADO descargado.', 'ok');
};

if (el.btnCloud) el.btnCloud.onclick = async () => {
  if (!hasInboxPayload()){
    alert('No hay datos para enviar (filiaciones o comparecencia).');
    return;
  }
  try{
    setStatus('Autenticando en COMPAPOL…');
    const user = await ensureDenupolAuth();
    if (!user) throw new Error('No se pudo validar la sesión.');

    if (!window.CompaCifrado?.wrapEncryptedJSON) {
      throw new Error('Falta módulo de cifrado (CompaCifrado).');
    }

    const payload = getInboxPayload();
    const inboxLabel = buildInboxLabel(payload);
    const tokenPublico = (typeof payload.token === "string" && payload.token.trim()) ? payload.token.trim() : null;
    setStatus('Cifrando JSON…');
    const wrappedText = await window.CompaCifrado.wrapEncryptedJSON(payload);
    let wrappedObj = null;
    try{
      wrappedObj = JSON.parse(wrappedText);
    }catch(_){
      throw new Error('No se pudo preparar el JSON cifrado.');
    }

    setStatus('Enviando a Inbox…');
    await denupolDb.collection('denupolInbox').add({
      ...wrappedObj,
      label: inboxLabel,
      tokenPublico,
      createdAt: firebase.firestore.FieldValue.serverTimestamp(),
      source: 'compa_api_github_release',
      sourceUserUid: user.uid || null
    });

    setStatus('JSON enviado a Inbox.', 'ok');
    alert('JSON enviado a Inbox.');
  }catch(e){
    const msg = String(e?.message || e || 'Error desconocido');
    setStatus(`Error Inbox: ${msg}`, 'err');
    alert(`Error Inbox: ${msg}`);
  }
};

if (el.btnCompartir) el.btnCompartir.onclick = async () => {
  if (!state.lastJson) return;
  const text = getJsonString();
  try{
    if (navigator.share) {
      await navigator.share({ title: 'COMPA-POL JSON', text });
      setStatus('JSON compartido.', 'ok');
      return;
    }
    await navigator.clipboard.writeText(text);
    setStatus('JSON copiado.', 'ok');
  }catch(e){
    console.error(e);
    setStatus('No se pudo compartir/copiar.', 'err');
  }
};

/* ========= Limpiar ========= */
el.btnLimpiar.onclick = () => {
  state.images = [];
  state.lastJson = null;
  state.aiJson = null;
  state.thumbOverrides = {};
  state.polling = false;
  try{ state.abort?.abort(); }catch{}
  state.abort = null;

  renderThumbs();
  if (el.docText) el.docText.value = "";
  el.docOut.value = "";
  el.filiacionesOut.innerHTML = "";
  setExportEnabled(false);
  setBusy(false);
  closeFiliacionOverlay();
  document.body.classList.remove('compare-on');
  if (el.btnToggleCompare){
    el.btnToggleCompare.textContent = '≣';
  }
  if (el.btnToggleFili){
    const bF = el.btnToggleFili;
    if (bF.firstChild && bF.firstChild.nodeType === Node.TEXT_NODE) bF.firstChild.nodeValue = '⊕';
    else bF.insertAdjacentText('afterbegin', '⊕');
  }
  setStatus("Limpio.");
  updateFiliUI();
  updateMainContentVisibility();
};

bootstrapAuthGate();

</script>
<script src="paises.js"></script>
<script src="paises_iso3.js"></script>
<script src="provincias_es.js"></script>
<script src="municipios.js"></script>
<script src="js/compa_crypto_resize.js?v=1"></script>
<script src="js/filiaciones_ui.js?v=4"></script>
<script src="js/compa_overlay_media.js?v=10"></script>
<script src="js/prewarm_agent.js?v=1"></script>
<script src="js/denupol_modal_bundle.js?v=10"></script>
</body>
</html>
